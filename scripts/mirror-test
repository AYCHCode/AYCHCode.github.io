#!/usr/local/bin/php -q
<?php # vim: ft=php

/*
 Ping each mirror, get what state they are in, and
 store in the local database. This data is used to
 automatically deactivate mirrors if needed. The
 gathered information is also mailed to the php-mirrors
 mailing list periodically by the mirror-summary
 script.
 
 TODO: notify a maintainer 24 hours before his mirror
       gets delisted
*/

// This script will run for a long time
set_time_limit (30 * 60);

// Connect to local MySQL database
mysql_connect("localhost","nobody","")
    or die("unable to connect to database");
mysql_select_db("php3");

// Get mirror information for all active mirrors (regardless of their type!)
$query = "SELECT active, maintainer, hostname, id, has_search, has_stats, lang
          FROM mirrors WHERE active = 1";
$result = mysql_query($query)
    or die("unable to get from the database: " . mysql_error());

// Get all mirror site data to the $hosts array
$hosts = array();
while ($row = mysql_fetch_array($result)) {
    $hosts[] = $row;
}

// Get all mirror sites, and count the index of them
foreach ($hosts as $index => $host) {

    // Open port 80 on the mirror site
    $fp = @fsockopen($host['hostname'], 80, $errno, $errstr, 15);
    
    // If we were unable to open the port, continue with the next mirror
    if (!$fp) {
        $hosts[$index]['problem'] = "unable to connect";
        continue;
    }
    
    // Request the exact file on www.php.net as it redirects
    // the request to a mirror site, and we would not handle
    // that properly...
    if ($row['hostname'] == 'www.php.net') {
        $filename = '/mirror-info.php';
    } else {
        $filename = '/mirror-info';
    }

    // GET mirror-info.php from the registered hostname
    $rc = fputs($fp, "GET $filename HTTP/1.0\r\n" .
                     "Host: {$host['hostname']}\r\n" .
                     "User-Agent: PHP.net Mirror Site Check\r\n");
    
    // If we were unable to write to socket, skip mirror site
    if ($rc === FALSE) {
        $hosts[$index]['problem'] = "unable to send request";
        continue;
    }
    
    // Set timeout to 5 seconds
    socket_set_timeout($fp, 5, 0);

    // Get lines from the socket, while we get past the HTTP headers
    // (HTTP headers and data have one empty line between them)
    do {
        $line = fgets($fp);
    } while ($line !== FALSE && $line != "" && $line != "\r\n" && $line != "\n");

    // If we were unable to pass the HTTP header, skip mirror site
    if ($line === FALSE || $line == "") {
        $hosts[$index]['problem'] = "didn't get past headers";
        continue;
    }
        
    // Get data row from socket
    $rv = fgets($fp);

    // If unable to read that row, skip mirror site
    if ($rv === FALSE) {
        $hosts[$index]['problem'] = "didn't get data";
        continue;
    }
    
    // Exlode information row by delimiter
    $info = explode("|", $rv);

    // Invalid data received, skip mirror site
    if (count($info) < 7) {
        $hosts[$index]['problem'] = "invalid data received (maybe improper ErrorHandler)";
        continue;
    }
    
    // Close socket
    fclose($fp);

    // Put pieces into the $hosts array
    $hosts[$index]['phpversion'] = $info[1];
    
    // The last updated date is a number [db security]
    if (is_numeric($info[2])) {
        $hosts[$index]['mirrorupdated'] = $info[2];
    } else {
        $hosts[$index]['problem'] = "invalid last update time";
    }
    
    // If new search information is available, override previous one
    if (in_array($info[3], array('0', '1', '2'))) {
        $hosts[$index]['has_search'] = $info[3];
    }

    // If stats is sure to be supported, update db
    if ($info[4] == '1') {
        $hosts[$index]['has_stats'] = $info[4];
    }

    // If language value is SQL safe, update it
    if (preg_match("!^[a-zA-Z_]+$!", $info[5])) {
        $hosts[$index]['lang'] = $info[5];
    }
    
    // Deactivate mirror immediately in case of a
    // manual alias is in effect
    if ($info[6] == "manual-alias") {
        $hosts[$index]['active'] = '0';
        $hosts[$index]['problem'] = "manual alias in effect";
    }
}

// Go through all mirror sites checked
$mirrorsupdated = 0; $problems = "";
foreach ($hosts as $host) {
    
    // If a "problem" is not specified, then we were able to check
    // the mirror, so the mirror data can be updated. Otherwise
    // the previous data need to be kept (except maybe "active")!
    if (!isset($host['problem'])) {
        $query = "UPDATE mirrors SET " .
                 "lastchecked = NOW(), " .
                 "lastupdated = FROM_UNIXTIME(" . $host['mirrorupdated'] . "), " .
                 "has_search = '" . ((int) $host['has_search'])     . "', " .
                 "has_stats = '"  . ((int) $host['has_stats'])      . "', " .
                 "phpversion = '" . addslashes($host['phpversion']) . "', " .
                 "lang = '"       . $host['lang']                   . "', " .
                 "ocmt = '' " .
                 "WHERE hostname = '" . $host['hostname'] . "'"; 
        $result = mysql_query($query) or die("unable to update the database: $query: " . mysql_error());
        if ($result) { $mirrorsupdated++; }
        else { $problems .= $host['hostname'] . " : cannot be updated in database\n"; }
    }

    // Store the problem encountered in the database, and collect
    // all the problems into one string in case it will be mailed
    else {
        $query = "UPDATE mirrors SET ocmt = '" . addslashes($host['problem']) . "', " .
                 "active = '" . ((int) $host['active']) . "' " .
                 "WHERE hostname = '" . $host['hostname'] . "'";
        $result = mysql_query($query) or die("unable to update the database: $query: " . mysql_error());
        $problems .= $host['hostname'] . " : " . $host['problem'] . "\n";
    }

}

// Send a debug mail at midnight with current details
if (intval(date("H")) == 0) {
    @mail(
        "goba@php.net",
        "Mirror site updates done",
        "$mirrorsupdated mirror sites properly updated (out of " . count($hosts) . ")\n\nProblematic mirrors:\n\n" . $problems
    );
}
