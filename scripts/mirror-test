#!/usr/local/bin/php -q
<?php # vim: ft=php

/*
 Ping each mirror, get what state they are in, and
 store in the local database. This data is used to
 automatically deactivate mirrors if needed. The
 gathered information is also mailed to the php-mirrors
 mailing list periodically by the mirror-summary
 script.
*/

// This script will run for a long time
set_time_limit (0);

// Debug mail
@mail("goba@php.net", "Mirror site check started", "Mirror site check started");

// Connect to local MySQL database
mysql_connect("localhost","nobody","")
    or die("unable to connect to database");
mysql_select_db("php3");

// Get mirror information for all active mirrors (regardless of their type!)
$query = "SELECT maintainer, hostname, id, has_search FROM mirrors WHERE active = 1";
$result = mysql_query($query)
    or die("unable to get from the database: " . mysql_error());

// Get the number of mirrors in the resultset
$total = mysql_num_rows($result);

// Get all mirror sites, and count the index of them
for($i = 0; $row = mysql_fetch_array($result, MYSQL_ASSOC); $i++) {

    // Add information gathered from database table
    $hosts[$i] = $row;

    // Open port 80 on the mirror site
    $fp = fsockopen($row['hostname'], 80, $errno, $errstr, 15);
    
    // If we were unable to open the port, continue with the next mirror
    if (!$fp) {
        // echo "unable to connect to $row[hostname]\n";
        continue;
    }

    // GET mirror-info.php from the registered hostname
    $rc = fputs($fp, "GET /mirror-info.php HTTP/1.0\r\nHost: $row[hostname]\r\n\r\n");
    
    // If we were unable to write to socket, skip mirror site
    if ($rc === FALSE) { continue; }
    
    // Set timeout to 5 seconds
    socket_set_timeout($fp, 5, 0);

    // Get lines from the socket, while we get past the HTTP headers
    // (HTTP headers and data have one empty line between them)
    do {
        $line = fgets($fp);
    } while ($line !== FALSE && $line != "" && $line != "\r\n" && $line != "\n");

    // If we were unable to pass the HTTP header, skip mirror site
    if ($line === FALSE || $line == "") {
        // echo "didn't get past headers for $row[hostname]\n";
        continue;
    }
        
    // Get data row from socket
    $rv = fgets($fp);

    // If unable to read that row, skip mirror site
    if ($rv === FALSE) {
        // echo "didn't get data for $row[hostname]\n";
        continue;
    }
    
    // Exlode information row by delimiter
    $info = explode("|", $rv);
    
    // Put pieces into the $hosts array
    $hosts[$i]['phpversion'] = $info[1];
    
    // The last updated date is a number [db security]
    if (is_numeric($info[2])) {
        $hosts[$i]['mirrorupdated'] = $info[2];
    }
    
    // If new search information is available, override previous one
    if (in_array($info[3], array('0', '1', '2'))) {
        $hosts[$i]['has_search'] = $info[3];
    }
}

// Go through all mirror sites checked
$mirrorsupdated = 0;
for($i=0; $i < $total; $i++) {
    
    // If "mirrorupdated" date specified, then we were able to check
    // the mirror, so the mirror data can be updated. Otherwise
    // the previous data need to be kept!
    if (isset($hosts[$i]['mirrorupdated'])) {
        $query = "UPDATE mirrors SET lastchecked = NOW(), has_search = " . $hosts[$i]['has_search'] . ", " .
                 "lastupdated = FROM_UNIXTIME(" . $hosts[$i]['mirrorupdated'] . "), " .
                 "phpversion = '" . addslashes($hosts[$i]['phpversion']) . "' " .
                 "WHERE hostname = '" . $hosts[$i]['hostname'] . "'"; 
        $result = mysql_query($query) or die("unable to update the database: $query: " . mysql_error());
        if ($results) { $mirrorsupdated++; }
    }
}

// Debug mail
@mail("goba@php.net", "Mirror sites checked", "$mirrorsupdated number of mirror sites properly updated");